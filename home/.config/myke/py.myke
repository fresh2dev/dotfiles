import json
import os
import subprocess
import sys
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from shutil import which
from subprocess import CompletedProcess, run
from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Sequence,
    Tuple,
    Union,
)

import myke


@myke.task(parents=("py"), name="fix")
def py_fix(*args: str):
    RUFF_EXE: List[str] = (
        [ruff] if (ruff := which("ruff")) else [sys.executable, "-m", "ruff"]
    )
    DELTA_EXE: Optional[str] = which("delta")

    def run_ruff(args: Sequence[str], **kwargs: Any) -> subprocess.CalledProcessError:
        return subprocess.run([*RUFF_EXE, *args], check=True, **kwargs)

    def input_from_options(options: Dict[str, str]):
        while True:
            print("\nProvide the key corresponding to the desired option:\n")
            for key, option in options.items():
                print(f"[{key}] {option}")
            choice: str = input("\nChoice: ")
            if options.get(choice):
                return choice
            print("Invalid choice.")

    @dataclass
    class RuffViolation:
        code: str
        count: int
        fixable: bool
        name: str
        summary: Optional[str] = None
        explanation: Optional[str] = None

        def __post_init__(self):
            rule_details: Dict[str, Any] = json.loads(
                run_ruff(
                    ["rule", "--output-format=json", self.code],
                    capture_output=True,
                ).stdout,
            )
            self.summary = rule_details.get("summary")
            self.explanation = rule_details.get("explanation")

        @classmethod
        def from_dict(cls, kv: Dict[str, Any], /):
            return cls(**{k: v for k, v in kv.items() if k in cls.__dataclass_fields__})

    def get_fixable_violations(args: Sequence[str]) -> Tuple[RuffViolation, ...]:
        p = run_ruff(
            [
                "check",
                *args,
                "--fixable=ALL",
                "--statistics",
                "--output-format=json",
                "--quiet",
                "--no-fix",
                "--exit-zero",
            ],
            capture_output=True,
        )

        return tuple(
            sorted(
                (
                    RuffViolation.from_dict(rule)
                    for rule in json.loads(p.stdout)
                    if rule.get("fixable")
                ),
                key=lambda x: x.code,
            ),
        )

    def ruff_review(args):
        first_pass: bool = True
        while True:
            fixable_violations: Tuple[RuffViolation, ...] = get_fixable_violations(args)
            if not fixable_violations:
                print("No fixable violations remain.")
                return

            if not first_pass:
                print("Fixable violations remain.")
                options: Dict[str, str] = {
                    "": "Run Again.",
                    "q": "Quit.",
                }

                selection = input_from_options(options)

                if selection == "q":
                    return

            first_pass = False

            for i, rule in enumerate(fixable_violations):
                rule_violations_by_file: Dict[str, int] = defaultdict(int)

                for x in json.loads(
                    run_ruff(
                        [
                            "check",
                            f"--select={rule.code}",
                            f"--fixable={rule.code}",
                            "--quiet",
                            "--no-fix",
                            "--exit-zero",
                            "--output-format=json",
                        ],
                        capture_output=True,
                    ).stdout,
                ):
                    if f := x.get("filename"):
                        rule_violations_by_file[
                            str(Path(f).relative_to(Path.cwd()))
                        ] += 1

                while rule_violations_by_file:
                    while True:
                        file = next(iter(rule_violations_by_file))
                        n_violations: int = rule_violations_by_file[file]
                        p = run_ruff(
                            [
                                "check",
                                f"--select={rule.code}",
                                f"--fixable={rule.code}",
                                "--quiet",
                                "--diff",
                                "--no-fix",
                                "--exit-zero",
                                file,
                            ],
                            capture_output=bool(DELTA_EXE),
                        )
                        if DELTA_EXE:
                            subprocess.run(
                                [DELTA_EXE, "--paging=never"],
                                check=False,
                                input=p.stdout,
                            )

                        file_diff = run_ruff(
                            [
                                "check",
                                f"--select={rule.code}",
                                f"--fixable={rule.code}",
                                "--quiet",
                                "--diff",
                                "--no-fix",
                                "--exit-zero",
                                file,
                            ],
                            capture_output=True,
                        ).stdout

                        print(
                            f"{sum(rule_violations_by_file.values())} total violation(s) of rule [{i + 1}/{len(fixable_violations)}]: [{rule.code}] {rule.summary}",
                        )
                        print()
                        print(f"{n_violations} reported violation(s) in file: {file}")
                        if len(rule_violations_by_file) > 1:
                            print()
                            print(
                                f"This rule is violated in {len(rule_violations_by_file) - 1} other file(s).",
                            )

                        options: Dict[str, str] = {
                            "h": f"View full help for rule {rule.code}.",
                            "f": f"Fix {rule.code} violations in this file.",
                            "F": f"Fix {rule.code} violations in all remaining files.",
                            "i": f"Ignore {rule.code} violations in this file.",
                            "I": f"Ignore {rule.code} violations in all remaining files.",
                            "v": "View proposed edits to this file.",
                            "r": "Refresh.",
                            "s": "Skip to next.",
                            "q": "Quit.",
                        }

                        selection = input_from_options(options)

                        if selection == "q":
                            return

                        if selection == "r":
                            continue

                        if selection == "h":
                            subprocess.run(
                                [
                                    os.getenv("EDITOR", "vim"),
                                    "-",
                                    "-c",
                                    "set ft=markdown",
                                ],
                                check=False,
                                input=run_ruff(
                                    ["rule", rule.code],
                                    capture_output=True,
                                ).stdout,
                            )

                            continue

                        if selection == "v":
                            if DELTA_EXE:
                                subprocess.run(
                                    [DELTA_EXE, "--paging=always"],
                                    check=False,
                                    input=file_diff,
                                )
                            continue

                        if selection == "s":
                            pass
                        elif selection == "f":
                            run_ruff(
                                [
                                    "check",
                                    f"--select={rule.code}",
                                    f"--fixable={rule.code}",
                                    "--fix",
                                    file,
                                ],
                            )
                            rule_violations_by_file.pop(file)
                        elif selection == "F":
                            run_ruff(
                                [
                                    "check",
                                    f"--select={rule.code}",
                                    f"--fixable={rule.code}",
                                    "--fix",
                                    *list(rule_violations_by_file),
                                ],
                            )
                            rule_violations_by_file.clear()
                        elif selection == "i":
                            run_ruff(
                                [
                                    "check",
                                    f"--select={rule.code}",
                                    f"--fixable={rule.code}",
                                    "--add-noqa",
                                    file,
                                ],
                            )
                        elif selection == "I":
                            run_ruff(
                                [
                                    "check",
                                    f"--select={rule.code}",
                                    f"--fixable={rule.code}",
                                    "--add-noqa",
                                    *list(rule_violations_by_file),
                                ],
                            )
                            rule_violations_by_file.clear()

                        rule_violations_by_file.pop(file, None)
                        break

            print("\nFin!\n")

    ruff_review(args)
